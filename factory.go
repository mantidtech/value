// Code generated by valuegenerator. DO NOT EDIT

package value

import (
	"fmt"
	"time"
)

// From creates a new Value variable from a given base value
func From(v interface{}) (ret Value) {
	switch x := v.(type) {
	case bool:
		p := new(bool)
		*p = x
		return BindBool(p)
	case *bool:
		p := new(bool)
		*p = *x
		return BindBool(p)
	case byte:
		p := new(byte)
		*p = x
		return BindByte(p)
	case *byte:
		p := new(byte)
		*p = *x
		return BindByte(p)
	case complex64:
		p := new(complex64)
		*p = x
		return BindComplex64(p)
	case *complex64:
		p := new(complex64)
		*p = *x
		return BindComplex64(p)
	case complex128:
		p := new(complex128)
		*p = x
		return BindComplex128(p)
	case *complex128:
		p := new(complex128)
		*p = *x
		return BindComplex128(p)
	case float32:
		p := new(float32)
		*p = x
		return BindFloat32(p)
	case *float32:
		p := new(float32)
		*p = *x
		return BindFloat32(p)
	case float64:
		p := new(float64)
		*p = x
		return BindFloat64(p)
	case *float64:
		p := new(float64)
		*p = *x
		return BindFloat64(p)
	case int:
		p := new(int)
		*p = x
		return BindInt(p)
	case *int:
		p := new(int)
		*p = *x
		return BindInt(p)
	case int8:
		p := new(int8)
		*p = x
		return BindInt8(p)
	case *int8:
		p := new(int8)
		*p = *x
		return BindInt8(p)
	case int16:
		p := new(int16)
		*p = x
		return BindInt16(p)
	case *int16:
		p := new(int16)
		*p = *x
		return BindInt16(p)
	case int32:
		p := new(int32)
		*p = x
		return BindInt32(p)
	case *int32:
		p := new(int32)
		*p = *x
		return BindInt32(p)
	case int64:
		p := new(int64)
		*p = x
		return BindInt64(p)
	case *int64:
		p := new(int64)
		*p = *x
		return BindInt64(p)
	case string:
		p := new(string)
		*p = x
		return BindString(p)
	case *string:
		p := new(string)
		*p = *x
		return BindString(p)
	case time.Duration:
		p := new(time.Duration)
		*p = x
		return BindDuration(p)
	case *time.Duration:
		p := new(time.Duration)
		*p = *x
		return BindDuration(p)
	case time.Time:
		p := new(time.Time)
		*p = x
		return BindTime(p)
	case *time.Time:
		p := new(time.Time)
		*p = *x
		return BindTime(p)
	case uint:
		p := new(uint)
		*p = x
		return BindUint(p)
	case *uint:
		p := new(uint)
		*p = *x
		return BindUint(p)
	case uint16:
		p := new(uint16)
		*p = x
		return BindUint16(p)
	case *uint16:
		p := new(uint16)
		*p = *x
		return BindUint16(p)
	case uint32:
		p := new(uint32)
		*p = x
		return BindUint32(p)
	case *uint32:
		p := new(uint32)
		*p = *x
		return BindUint32(p)
	case uint64:
		p := new(uint64)
		*p = x
		return BindUint64(p)
	case *uint64:
		p := new(uint64)
		*p = *x
		return BindUint64(p)
	default:
		err := fmt.Errorf("cannot convert object type %T to a Value", x)
		panic(err)
	}
}

// Bind a base value to a Value variable
func Bind(v interface{}) (ret Value) {
	switch x := v.(type) {
	case *bool:
		return BindBool(x)
	case *byte:
		return BindByte(x)
	case *complex64:
		return BindComplex64(x)
	case *complex128:
		return BindComplex128(x)
	case *float32:
		return BindFloat32(x)
	case *float64:
		return BindFloat64(x)
	case *int:
		return BindInt(x)
	case *int8:
		return BindInt8(x)
	case *int16:
		return BindInt16(x)
	case *int32:
		return BindInt32(x)
	case *int64:
		return BindInt64(x)
	case *string:
		return BindString(x)
	case *time.Duration:
		return BindDuration(x)
	case *time.Time:
		return BindTime(x)
	case *uint:
		return BindUint(x)
	case *uint16:
		return BindUint16(x)
	case *uint32:
		return BindUint32(x)
	case *uint64:
		return BindUint64(x)
	default:
		err := fmt.Errorf("cannot bind object type %T to a Value (is it a pointer?)", x)
		panic(err)
	}
}
